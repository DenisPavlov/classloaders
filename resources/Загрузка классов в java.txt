По любому нужно сказать

Java – язык с отложенной (ленивой) загрузкой классов. Первоначально загружается только один класс – тот, который передан в качестве параметра утилите «java».
Как только код этого класса обращается к какому-то другому классу (любым способом: вызовом конструктора, обращением к статическому методу или полю), загружается другой класс.
Ни один класс не загружается до тех пор, пока в нем не возникнет реальная потребность.

виртуальная машина считывает команды, представленные в class-файлах в виде байт-кода и транслирует их в виде инструкций процессору, Предлагаю немного разобраться в схеме попадания байт-кода в виртуальную машину.

В ява класс может загружаться как из скомпилированного байт кода (хранится в файлах с расширением .class), но может быть также получен из других источников, например, загружен по сети или же сгенерирован самим приложением

Согласно спецификации Java SE для того, чтобы получить работающий в JVM код, необходимо выполнить три этапа:
- загрузка байт-кода из ресурсов и создание экземпляра класса Class
- связывание (или линковка)
	- Verification, происходит проверка корректности полученного байт-кода.
	- Preparation, выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию (при этом явная инициализация, если она есть, происходит уже на этапе инициализации).
	- Resolution, разрешение символьных ссылок типов, полей и методов.
- инициализация полученного объекта

Типы загрузчиков Java
- Bootstrap - базовый загрузчик, также называется Primordial ClassLoader. загружает стандартные классы JDK из архива rt.jar
- Extension ClassLoader – загрузчик расширений. загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext, но могут быть заданы системным свойством java.ext.dirs
- System ClassLoader – системный загрузчик. загружает классы приложения, определенные в переменной среды окружения CLASSPATH

В Java используется иерархия загрузчиков классов, где корневым, разумеется, является базовый. Далее следует загрузчик расширений, а за ним уже системный. Естественно, каждый загрузчик хранит указатель на родительский для того, чтобы смочь делегировать ему загрузку в том случае, если сам будет не в состоянии этого сделать.

Абстрактный класс ClassLoader
Каждый загрузчик, за исключением базового, является  потомком абстрактного класса java.lang.ClassLoader. Например, реализацией загрузчика расширений является класс sun.misc.Launcher$ExtClassLoader, а системного загрузчика – sun.misc.Launcher$AppClassLoader. Базовый загрузчик является нативным и его реализация включена в JVM.

Любой класс, который расширяет java.lang.ClassLoader, может предоставить свой способ загрузки классов

Также в Java поддерживается понятие «текущего» загрузчика классов. Текущий загрузчик это тот, который загрузил класс, выполняющийся в данный момент. Каждый класс знает, каким загрузчиком он был загружен, и можно получить эту информацию, вызвав у него метод String.class.getClassLoader(). Для всех классов приложения «текущий» загрузчик, как правило, системный.

Три принципа загрузки классов
- Делегирование

Запрос на загрузку класса передается родительскому загрузчику, и попытка загрузить класс самостоятельно выполняется, только если родительский загрузчик не смог найти и загрузить класс. Такой подход позволяет загружать классы тем загрузчиком, который максимально близко находится к базовому. Так достигается максимальная область видимости классов. Каждый загрузчик ведет учет классов, которые были загружены именно им, помещая их в свой кэш. Множество этих классов и называется областью видимости.

- Видимость

Загрузчик видит только «свои» классы и классы «родителя» и понятия не имеет о классах, которые были загружены его «потомком».

- Уникальность

Класс может быть загружен только однажды. Механизм делегирования позволяет убедиться, что загрузчик, инициирующий загрузку класса, не перегрузит загруженный ранее в JVM класс.

Схема загрузки классов
Когда происходит вызов загрузки какого-либо класса, происходит поиск этого класса в кэше уже загруженных классов текущего загрузчика.

Если желаемый класс еще не загружался ранее, по принципу делегирования управление передается родительскому загрузчику, который находится по иерархии на уровень выше. Родительский загрузчик также пытается найти желаемый класс у себя в кэше. Если класс уже был загружен и загрузчик знает о его местонахождении, то будет возвращен объект Class этого класса. Если нет, поиск будет продолжаться до тех пор, пока не дойдет до базового загрузчика. Если и в базовом загрузчике нет информации об искомом классе (т.е. он еще не был загружен), будет выполнен поиск байт-кода этого класса по расположению классов, о котором знает данный загрузчик, и, если загрузить класс не удастся, управление вернется обратно загрузчику-потомку, который будет пытаться выполнить загрузку из известных ему источников. Как уже упоминалось выше, расположение классов для базового загрузчика это библиотека rt.jar, для загрузчика расширений – каталог с расширениями jre/lib/ext, для системного – CLASSPATH, для пользовательского это может быть что-то свое.


Добавить примеры (например application server tomcat), где много загрузчиков классов.


Часть 2

Плагины (подключаемые модули) используются везде: в средах разработки, в браузерах, в файловых менеджерах и в медиа-плеерах. Сложно найти серьезное приложение, которое не предоставляло бы возможности расширения своих функциональных возможностей путем установки дополнительных плагинов. Даже небольшой текстовый редактор Notepad++ позволяет подключать плагины.

- Плагины получают доступ к объектам “ядра” приложения. Это нежелательно: плагины должны жить в своей собственной “песочнице”.

Для того, чтобы создать приложение, лишенное указанных недостатков, необходимо реализовать механизм, который позволит подгружать нужные классы во время исполнения приложения и ограничивать их "зону видимости". В Java таким механизмом являются ClassLoader’ы.

На классический вопрос: как идентифицировать класс внутри JVM? Обычно отвечают – при помощи полного имени: имя пакетов плюс имя самого класса. Этот ответ не совсем полный/верный. В JVM вполне нормально могут существовать два разных класса с одинаковыми "полными" именами. Класс в JVM однозначно определяется своим полным именем и ClassLoader’ом, который его загрузил. Таким образом осуществляется изоляция ядра приложения.

ClassLoader’ы в Java имеют иерархическую структуру. Это означает, что loader-наследник "видит" все "свои" классы плюс классы loader’а-родителя. В то время, когда JVM начинает исполнять стартовый метод main, уже существует три class loader’a:

Bootstrap ClassLoader – вершина иерархии ClassLoader’ов. Загружает классы ядра Core Java.
Extension ClassLoader – загружает библиотеки из lib/ext. Наследуется от Bootstrap.
System ClassLoader – загружает классы из classpath. Наследуется от Extension.

Метод main инициализируется в System ClassLoader’е. Что же происходит, когда программа пытается обратиться к какому-нибудь классу, т.е. создать экземпляр, или выполнить Class.forName(…), который содержится в библиотеках из lib/ext?

System Class loader пробует загрузить класс, используя Extension Class loader.
Extension Class loader “просит” Bootstrap загрузить класс.
Bootstrap не может загрузить класс, ведь ему видны только Core классы. А искомый класс лежит в библиотеке из lib/ext.
Extension Class loader пытается загрузить класс. Если ему это удается, то он возвращает класс в System Class Loader.
System Class loader не пытается что-либо загружать. Класс уже найден.

Какой класс будет реально загружен, если в lib/ext и в classpath есть классы с одинаковым именем? Конечно же класс из lib/ext – на classpath никто и смотреть не будет. То же самое касается и порядка элементов в classpath – класс будет загружен из первого по очереди источника. То есть, если есть a.jar и b.jar и оба содержат класс com.foo то при выполнении
java -cp a.jar;b.jar ...
будет использоваться класс из a.jar, а при выполнении

java -cp b.jar;a.jar ...
из b.jar.

Чтобы изолировать плагины друг от друга достаточно загружать их в отдельных ClassLoader’ах.

Чтобы создать новый экземпляр URLClassLoader'а в конструктор этого класса нужно передать массив url’ов (папок и jar-файлов) и, указать объект ClassLoader, который URLClassLoader будет считать своим родителем. Если родителя явно не передавать, URLClassLoader будет пронаследован от текущего ClassLoader'а. А если передать null – то от Bootstrap ClassLoader'a. На этот нюанс следует обращать внимание.


ClassLoader обеспечивает загрузку классов Java. Если говорить точнее, обеспечивают загрузку его наследники, конкретные загрузчики классов – сам ClassLoader абстрактен. Каждый раз, когда загружается какой-либо .class-файл, например, вследствие обращения к конструктору или статическому методу соответствующего класса – на самом деле это действие выполняет один из наследников класса ClassLoader.

Существует стандартный вариант реализации ClassLoader – так называемый системный загрузчик классов. Этот загрузчик используется по умолчанию при запуске приложений Java командой:
java Имя_главного_класса

Одна из замечательных особенностей языка Java заключается в том, что можно реализовать свой собственный загрузчик классов – наследник ClassLoader – и использовать его вместо системного.

Реализуя наследников ClassLoader, можно полностью контролировать процесс загрузки абсолютно всех Java-классов. Можно загружать их из любого источника, к примеру, из собственной системы каталогов, не отраженной в CLASSPATH, из базы данных или из Internet. Можно предоставить загрузку стандартных библиотечных классов системному загрузчику, но при этом протоколировать факт обращения к ним. При желании можно даже сконструировать байт-код класса в памяти и после этого работать с ним, как с нормальным классом, загруженным из «добропорядочного» .class-файла. Среди компилируемых языков подобные возможности встречаются разве что в ассемблере.

Единственное, что нельзя сделать с помощью ClassLoader'a – это создать новый класс, не располагая его байт-кодом. Для создания нового класса необходимо получить корректный байт-код класса (образ в памяти обычного .class-файла) в виде массива byte[]. Затем его нужно передать специальному стандартному методу ClassLoader.defineClass, который «превратит» его в готовый класс – объект типа Class.

Когда запускается приложение Java с помощью стандартной команды:

java Имя_главного_класса
виртуальная машина Java первым делом создает системный загрузчик, загружает с его помощью .class-файла вашего главного класса и вызывает статический метод вашего класса, соответствующий объявлению:

public static void main(String[] argv)

Java – язык с отложенной загрузкой кода. Первоначально загружается только один класс – тот, который передан в качестве параметра утилите «java». Как только код этого класса обращается к какому-то другому классу (любым способом: вызовом конструктора, обращением к статическому методу или полю), загружается другой класс. По мере выполнения кода, загружаются всё новые и новые классы. Ни один класс не загружается до тех пор, пока в нем не возникнет реальная потребность. Такое поведение заложено в стандартный системный загрузчик.

Загрузчик, загрузивший некоторый класс, всегда можно узнать, вызвав метод getClassLoader у объекта типа Class, соответствующего данному классу :
public ClassLoader getClassLoader()

Когда возникает необходимость загрузить другой класс вследствие обращения к его конструктору, статическому методу или полю, виртуальная Java-машина автоматически обращается к текущему загрузчику классов, о котором «помнит» текущий исполняемый класс. При этом другой класс также «запоминает» этот загрузчик в качестве текущего. Иначе говоря, текущий загрузчик, загрузивший данный класс, по умолчанию наследуется всеми классами, прямо или косвенно вызываемыми из данного.

Стандартный способ загрузить некоторый класс загрузчиком, отличным от текущего – специальная версия статического метода Class.forName:
public static Class forName(String name, boolean initialize, ClassLoader loader);

В качестве name передается полное имя класса (с указанием пакета), в качестве loader – требуемый загрузчик. Не столь очевидный (и не столь важный) параметр initialize управляет инициализацией класса, т.е. установкой значений всех static-полей класса и исполнением кода в секциях:

static {

  ...

}
Если значение initialize равно true, то инициализация происходит немедленно, в противном случае – откладывается до первого обращения к любому конструктору, статическому методу или полю этого класса.

Class.forName(name) эквивалентен вызову Class.forName(name, true, Текущий_класс.class.getClassLoader());

Загрузив класс, можно создать его экземпляр или вызвать статический метод средствами отражений. Дальше этот класс может обычными средствами языка Java обращаться к другим классам – для них будет вызван тот же самый загрузчик loader (либо какие-то другие загрузчики, если реализация loader в какой-то момент «решит» передать управление другому загрузчику). Простейший пример:

Class class_= Class.forName("Имя_класса", true, нестандартный_загрузчик);

class_.newInstance(); // создается экземпляр класса

Методы класса ClassLoader
Полный список методов можно найти в документации к ClassLoader'у? В данной статье рассмотрены наиболее важные из них.

Один из методов ClassLoader был уже рассмотрен. Это статический метод, возвращающий ссылку на стандартный системный загрузчик.
public static ClassLoader getSystemClassLoader()


public Class loadClass(String name)
Этот метод загружает класс с заданным именем. На самом деле его реализация сводится к вызову другого protected-метода:

protected synchronized Class loadClass(String name, boolean resolve);

Имеется также группа public методов, предназначенных для загрузки ресурсов:

public URL getResource(String name);

public InputStream getResourceAsStream(String name);

public final Enumeration getResources(String name);

public static URL getSystemResource(String name);

static InputStream getSystemResourceAsStream(String name);

static Enumeration getSystemResources(String name);

Методы Class.getResource и Class.getResourceAsStream обращаются к соответствующим методам текущего загрузчика, загрузившего данный класс. Главное отличие методов работы с ресурсами класса ClassLoader – абсолютные пути. Путь к ресурсу отсчитывается не от каталога, содержащего данный class-файл (как в случае Class.getResource и Class.getResourceAsStream), а от одного из каталогов, указанных в переменной CLASSPATH.


Перезагрузка классов «на лету»

Итак, основная задача – написать загрузчик классов, аналогичный стандартному системному, который, в отличие от него, умел бы «забывать» загруженные ранее версии классов и загружать .class-файлы заново.

Назовем новый загрузчик DynamicClass-Overloader – «динамический перезагрузчик классов».

Итак, необходимо создать наследника абстрактного класса ClassLoader, который умел бы загружать классы из некоторого заданного набора каталогов поиска также, как это делает системный загрузчик для каталогов, перечисленных в переменной CLASSPATH. В отличие от системного загрузчика наш вариант ClassLoader должен уметь «забывать» о загруженных ранее классах. Для этого необходимо реализовать следующие методы ClassLoader'а:

protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException;
protected Class findClass(String name) throws ClassNotFoundException;
protected java.net.URL findResource(String name);
protected java.util.Enumeration findResources(String name) throws IOException;









Вопросы
1) Как получить загрузчик классов имея класс
2) Почему нельзя вызвать класслоадер из статического метода ?
3) Почему возникает исключение ClassNotFoundException, NoClassDefFoundError ?
4) Можно ли из одного кастомного загрузчика посучаться в другой, если они на одном уровне иерархии ?
5) Можно ди в приложении иметь два класса с одинаковыми именами?
6) Замутить ClassCastException

Во-во. Честно говоря, статья получилась ни о чем.
Ни про URLClassLoader или зачем вообще нужны пользовательские загрузчики, ни про выгрузку классов, ни про взаимоотношения class loading / class linking / class initialization, ни про Class Data Sharing.
Ну, разве что в следующей статье, которая обещана быть интересней…


Так исключение ClassNotFoundException возникает при динамической загрузке класса во время выполнения программы, когда загрузчики не могут найти требуемый класс ни в кэше, ни по пути нахождения классов.


https://javarush.ru/groups/posts/646-kak-proiskhodit-zagruzka-klassov-v-jvm
https://www.cis.upenn.edu/~bcpierce/courses/629/papers/Saraswat-javabug.html
https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html
https://javarevisited.blogspot.com/2012/12/how-classloader-works-in-java.html
http://java-online.ru/java-classloader.xhtml
http://java-online.ru/blog-plugin.xhtml#plugin-classloader
